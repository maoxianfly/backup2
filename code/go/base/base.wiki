%title Go语言基础语法

[[../../../index|首页]] - [[../index|Go]] - [[index|Base]]
==Go语言基础语法==
----
===语言约定===

所有的`Go`源文件都必须以`package 包名`开头，如果是独立运行的执行文件则必须是`package main`

一个`Go`源文件，首先是出现`package 包名`，紧跟着然后就是`import "库名"`，再然后才是程序的其他部分

和`C/C++`一样，每个`Go`程序都必须有一个`main`函数，且程序总是从`main`开始执行
----
===语言特色===

`Go`语句不需要尾部的分号，除非是将多条语句书写在同一行，那就需要用到分号了

`Go`最大的不同在于，其他语言都是将类型放在变量名前面，而`Go`正好相反，类型位于变量名之后，如 `var a int`（`C语言`写作 `int a;`）

编译器相当严格，如果程序中存在声明了但未使用的变量，编译器直接报错而不是警告（导入的包没有使用也一样会报错）

原生支持复数

没有`逗号`表达式，没有三元运算符`? :`

同一源文件中，可以在一个函数还没定义的情况下调用执行，不再需要`C/C++`中的函数原型声明

控制结构强制使用大括号，而且大括号强制缩进，可以说，`Go`就是为了打造成一门具有高规范度的工业级语言
----
===变量赋值===

`Go`有两套赋值语法，一种是`var a int = 15`的形式，另一种是`a := 15`，但后一种形式只能用于函数里面

`:=`的形式是可以自行推导变量类型的，赋值时无需声明类型

`var`的形式允许同时声明多个变量，如 `var x, y int = 10, 20`，相当于其他语言里的 `int x = 10, y = 20;`

类似的，`:=`也支持多个变量的同时声明，如 `a, b := 10, 20`

多个变量也可以成组声明，语法形式如下（`const`和`import`也支持这样的用法）

{{{Go
var(
  x int
  y string
  z bool
)
}}}

`Go`有一个特殊的变量，`_`（下划线），任何赋给它的值都会被丢弃，如 `_, a := 1, 2`，`1`将被丢弃，`a`的值为`2`
----
===数据类型===

`C/C++`中，强制类型转换使用的形式是`(int)a`，而在`Go`中写法为`int32(a)`

====布尔型====

布尔型（`bool`）有两个值，`true`和`false`。在格式化输出`bool`类型时，格式符为`%v`，`%v`的意思是使用默认格式

====数值类型====

数值类型有以下种类：

`byte`、`rune`、`int`、`int8`、`int16`、`int32`、`int64`、`int64`、`uint8`、`uint16`、`uint32`、`uint64`、`float32`、`float64`

`byte`是`uint8`的别名，`rune`是`int32`的别名，需要注意的是，`Go`没有`float`类型，只有`float32`和`float64`

以上各种数据类型不能混用，这点`Go`表现得比其他语言严格得多

此外还支持`八进制`、`十六进制`和`科学计数法`

====常量====

`Go`使用`const`关键字声明常量，声明语法如下：

{{{Go
<pre class="brush: Go">
// 第一种
const x = 20

// 第二种1
const(
  a = 1
  b = 2
)

// 第二种2，自动生成枚举值
const(
  a = iota  // a = 0
  b = iota  // b = 1
  c = iota  // c = 2
)

// 第二种3，使用自动枚举时，可以省略后续的符号
const(
  a = iota  // a = 0
  b         // b = 1
  c         // b = 2
)

// 第二种4，指定常量的类型
const(
  a = 4
  b string = "Ruchee"
)
</pre>
}}}

====字符串====

单引号包围的是字符，双引号包围的是字符串，`Go`语言的字符串是不可变的，不像`C语言`一样可以将字符串当数组来用

字符串声明示例：`var s string = "Ruchee"`、`s := "Ruchee"`

多行字符串使用`+`相连，但`+`号必须书写在上一行字符串的末尾，这样才能避免编译器识别错误，如下所示：

{{{Go
s := "Hello " +
     "World!"
}}}

多行字符串还可以使用`反引号`来包围（`反引号`一般位于数字键`1`的左边），这种方式可以将字符串里面的内容原封不动的传送，但换行符和其他转义字符依然有效

====复数====

复数的变量类型有`complex64`和`complex128`两种，打印复数使用的格式符是`%v`

下面是使用示例：

{{{Go
<pre class="brush: Go">
var c complex64 = 2 + 3i

fmt.Printf("c = %v\n", c)  // 输出结果为：c = (2+3i)
</pre>
}}}

====错误类型====

`Go`专门为错误内建了一个数据类型`error`，其默认初始值为`nil`
----
===操作符===

`Go`支持常规的位运算与逻辑运算，使用的符号也与`C语言`一致

但`Go`除了支持`&`、`|`、`^`以外，还提供了一个`位清除`运算符`&^`，譬如`var a, b int = 3, 2`，则`a &^ b`则表示`a`中凡是与`b`中`1`对应的位都被清除为`0`，所以`11`被`10`清除为`01`，结果为`1`

支持常见的复合运算符，如 `+=`、`-=`等

支持自加、自减运算符，但`++`与`--`都只允许后置，不能放在变量前面，所以`++i`的写法是错误的，只能写成`i++`
----
===控制结构===

`Go`对控制结构进行了大幅缩减，没有了`do`，没有了`while`，只有`if`、`switch`和`for`，另外增加了一个用于多路通讯转接器的`select`

`if`和`switch`可以有初始化语句，就像`for`一样，这通常用于设置一个局部变量

`if-else`的条件部分不需要使用括号（用括号也`OK`，不会报错），且`if-else`强制缩进，各个选择分支也强制使用大括号包围

`switch`进行了扩展，其可以没有用于判别的表达式（这将默认匹配为`true`），且每条`case`分支会在匹配后自动中断执行，如果需要继续向下匹配就必须显式使用关键字`fallthrough`

每条`case`分支的匹配项不再仅限于一个数据，可以使用一个逗号分隔的列表，如下所示：

{{{Go
<pre class="brush: Go">
switch c{
  case 0:
    xxx
  case 1, 2, 3, 4, 5, 6, 7, 8, 9:
    xxx
  case 10:
    xxx
}
</pre>
}}}

`for`有三种形式，分别如下：

{{{Go
<pre class="brush: Go">
// 第一种，和C语言的for差不多
for init; condition; post {}

// 第二种，相当于C语言的while
for condition {}

// 第三种，相当于C语言的for(;;)，死循环
for {}
</pre>
}}}

支持`return`、`break`和`continue`这三个关键字，除了`break`支持自定义标签中断外，其他都与`C语言`别无二致

`Go`保留了`goto`关键字，只允许在函数内部跳转，不能跨越多个函数（使用方法和`C语言`一样）

`Go`另外增加了一个迭代器`range`，用于遍历`array`、`string`、`map`等数据结构，它可以很容易实现索引与内容的拆分
----
<red>date</red> : 2012-06-16、2012-11-13
----
