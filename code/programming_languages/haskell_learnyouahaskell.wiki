%title Haskell趣学指南笔记

[[../../index|首页]] - [[../index|Code]]
==Haskell趣学指南笔记==
----
===GHCI常用指令===

# `:?`：显示所有可用指令
# `:!`：执行系统命令，如 `:!clear` 清屏
# `:set editor`：设置默认编辑器，如 `:set editor vim` 将默认编辑器设置为 `Vim`
# `:set prompt`：修改默认提示符，如 `:set prompt "Ruchee> "` 将默认的 `Prelude> ` 改成 `Ruchee> `
# `:load`：加载代码文件，简写为 `:l`，如 `:l abc.hs` 加载文件 `abc.hs`（可省略文件后缀，如 `:l abc`）
# `:reload`：重新加载代码文件，简写为 `:r`，如 `:r abc.hs` 重新加载文件 `abc.hs`
# `:type`：查看表达式的类型，简写为 `:t`，如 `:t "Ruchee" => "Ruchee" :: [Char]`，对于运算符函数，如 `+、-、*、/、>、<、==` 之类的，则必须以括号包围，如 `:t (+)`
# `:quit`：退出 `GHCI`
# `let`：在交互环境中创建变量，如 `let a = 1`，相当于在代码文件中书写 `a = 1`
----
===运算逻辑===

像 `5 * -3` 这样的表达式，其他编程语言如 `C/C++`、`PHP` 等都可以正确处理，但 `Haskell` 不行，得写成 `5 * (-3)`

真、假、与、或、非：`True`、`False`、`&&`、`||`、`not`（`True` 和 `False` 区分大小写）

相等、不等：`==`、`/=`
----
===流程控制===

`if-then-else`：`if xx then yy else zz`，其中 `else` 分支不可省略，因为 `Haskell` 要求每一个表达式都要返回一个结果
----
===函数===

函数分 `前缀` 和 `中缀`，常见为 `前缀函数`，可用反引号包围函数名，将前缀函数以中缀形式调用

函数调用拥有最高的优先级，函数的执行与函数的声明先后无关

`C/C++` 等语言中，`括号` 是函数调用不可缺少的组成部分，而 `Haskell` 中，`空格` 才是函数调用不可缺少的组成部分

函数定义的基本形式：`函数名 参数表列 = 函数体`，其中 `函数名` 首字母不允许大写，没有参数的函数相当于定义

`Haskell` 习惯于在函数名后加单引号来表示一个稍经修改但差别不大的函数，如函数 `func` 和 `func'`
----
===列表===

`List`：`[元素1, 元素2, 元素3, ...]`，相当于 `C/C++` 等语言中的数组，只能存储同类型的数据

`List` 的元素也可以是 `List`，且作为元素的各个 `List` 可以有不同的长度，但不能有不同的数据类型

`字符串` 只是 `List` 的语法糖，如 `Ruchee` 其实就是 `['R', 'u', 'c', 'h', 'e', 'e']`，所以一切可用于 `List` 的函数都可用于 `字符串`

`List` 常用操作（注意 `head`、`tail`、`last`、`init` 作用于空列表会出错，且不会被编译器捕获）
* `++`：连接两个 `List`，如 `[1, 2, 3] ++ [4, 5] => [1, 2, 3, 4, 5]`、`"Hello" ++ " " ++ "World" => "Hello World"`
* `:`：将左边的元素插入右边 `List` 的最前面，如 `1 : [2, 3] => [1, 2, 3]`、`'A' : " good boy" => "A good boy"`
* `!!`：索引 `List` 元素，下标从 `0` 开始，如 `[1, 2, 3] !! 0 => 1`、`"Ruchee" !! 0 => 'R'`
* `..`：按指定区间产生连续元素，步长可根据前面的逻辑自动推导，如 `[2, 4 .. 10] => [2, 4, 6, 8, 10]`
* `>`、`>=`、`<`、`<=`、`==`、`/=`：比较两 `List`，这将从两 `List` 各自的第一个元素开始比较起
* `head`：取得 `List` 的第一个元素，如 `head [3, 2, 1] => 3`
* `tail`：取得 `List` 除去第一个元素后的部分，如 `tail [3, 2, 1] => [2, 1]`
* `last`：取得 `List` 的最后一个元素，如 `last [3, 2, 1] => 1`
* `init`：取得 `List` 除去最后一个元素后的部分，如 `init [3, 2, 1] => [3, 2]`
* `length`：计算一个 `List` 元素的个数，如 `length [1, 2, 3] => 3`
* `null`：检查一个 `List` 是否为空，如 `null [] => True`
* `reverse`：反转一个 `List`，如 `reverse [1, 2, 3] => [3, 2, 1]`
* `take`：取得 `List` 的前 `N` 个元素，如 `take 3 [1, 2, 3, 4, 5] => [1, 2, 3]`
* `drop`：删除 `List` 的前 `N` 个元素，如 `drop [1, 2, 3, 4, 5] => [4, 5]`
* `sum`：计算一个 `List` 所有元素的总和，如 `sum [1, 2, 3] => 6`
* `elem`：判断一个元素是否包含于指定 `List` 中，如 `elem 0 [1, 2, 3] => False`
* `maximum`：返回一个 `List` 中值最大的元素，如 `maximum [1, 2, 3] => 3`
* `minimum`：返回一个 `List` 中值最小的元素，如 `minimum [1, 2, 3] => 1`
* `cycle`：接受一个 `List`，然后返回一个以该 `List` 对应的字符串循环作为元素组成的无限 `List`，如 `take 18 (cycle "Ruchee") => "RucheeRucheeRuchee"`
* `repeat`：接受一个参数值，然后返回一个以该值循环作为元素组成的无限 `List`，如 `take 3 (cycle "Ruchee") => ["Ruchee","Ruchee","Ruchee"]`
* `replicate`：生成一个由 `N` 个重复元素组成的 `List`，如 `replicate 3 "Ruchee" => ["Ruchee","Ruchee","Ruchee"]`
* `zip`：接受两个 `List`，将两 `List` 的各个元素两两结合成 `Pair`，然后返回一个以这些 `Pair` 为元素的 `List`，如 `zip [1, 2, 3] [4, 5, 6] => [(1,4),(2,5),(3,6)]`
----
===元组===

`Tuple` 和 `List` 很相似，但 `Tuple` 不要求元素类型的一致性，且 `Tuple` 本身的类型随其元素个数的不同而不同

相同类型的 `Tuple` 可以像 `List` 一样比较大小，两元素的 `Tuple` 又称为`序对`（`Pair`）

`Pair` 常用操作
* `fst`：返回一个 `Pair` 的首项
* `snd`：返回一个 `Pair` 的尾项
----
===集合===

集合的基本形式：`[表达式 | 筛选条件1, 筛选条件2, ...]`，如 `[x | x <- [50..100], (mod x 7) == 3]` 可以取得所有 `50` 到 `100` 之间，且除 `7` 的余数为 `3` 的数字
----
===类型系统===

`Haskell` 可自动推导数据类型，函数也是表达式，所以函数也有类型

类型声明的基本形式如下：
{{{
-- 类型声明
函数名 :: (类型约束) => 参数1的类型 -> 参数2的类型 -> ... -> 函数返回值的类型
-- 函数定义
函数名 参数1 参数2 ... = 函数体
}}}

常用的几大类型
* `Int`：有界整数
* `Integer`：无界整数
* `Float`：单精度浮点数
* `Double`：双精度浮点数
* `Bool`：布尔值
* `Char`：字符
* `String`：字符串，即 `[Char]`

几个基本的类型类（`Typeclass`）
* `Eq`：包含可判断相等性的类型，实现函数是 `==` 和 `/=`，除函数以外的所有类型都属于 `Eq`，所以除函数以外的所有类型都可以判断相等性
* `Ord`：包含可比较大小的类型，实现函数为 `<、>、<=、>=` 等
* `Show`：包含可用字符串表示的类型
* `Read`：与 `Show` 作用相反，用于将字符串转换成合理的其他类型数据
* `Enum`：包含连续的（可枚举）类型
* `Bounded`：包含有上下限的类型，可使用 `maxBound :: 类型` 和 `minBound :: 类型` 取得最大值和最小值
* `Num`：包含具有数字特征（实数和整数）的类型
* `Integral`：仅包含整数类型，`Int` 和 `Integer` 都是其成员类型
* `Floating`：仅包含浮点类型，`Float` 和 `Double` 都是其成员类型
----
===模式匹配===

`Haskell` 的函数既可以使用 `if-then-else` 来分别处理不同的参数，也可以通过定义多个平行的函数来实现，基本形式如下：
{{{
-- 类型声明
函数体 :: (类型约束) => 参数类型表列（用->分隔） -> 函数返回值类型
-- 函数定义1
函数名 参数表列1（用空格分隔） = 函数体1
-- 函数定义2
函数名 参数表列2（用空格分隔） = 函数体2
...
-- 通用函数定义
函数名 通用参数表列（用空格分隔） = 通用函数体
}}}

这样的多重平行定义有点像命令式语言里的 `switch-case-default` 结构，最一般的匹配放在最后

可以在模式匹配最前面放置 `@` 符号，以便于方便地引用模式整体，如 `all@(x:xs)`，则调用 `all` 就免去了写 `[x:xs]`

可在函数名和参数表列后加竖线（`|`）来使用模式防卫（`guard`）功能，这有点像 `if` 语句，其返回为布尔值，为 `True` 则使用其对应的函数体，否则转到下一个模式防卫
{{{
函数名 参数表列
  | 防卫1 = 函数体1
  | 防卫2 = 函数体2
  ...
  | otherwise = 默认函数体
}}}

默认的模式防卫放在最后，其表达式写作 `otherwise`，其实 `otherwise` 就是一个定义为 `True` 的值而已

为避免在多个 `guard` 中使用同一表达式，可配合使用 `where` 语句将表达式定义成标量，以实现一次编写多次引用

使用 `let-in` 结构可以随处定义局部变量或局部函数，且这些局部变量只对对应的 `in` 可见，`in` 子句可省略

模式匹配本质只是 `case` 语句的语法糖，`case` 的基本语法如下：
{{{
case 表达式 of 模式1 -> 执行体1
               模式2 -> 执行体2
               ...
}}}
----
<red>date</red> : 2013-07-05、2013-07-08
----
