%title 正则基础

[[../../../index|首页]] - [[../index|Perl]] - [[index|RegEx]]
==正则基础==
----
`Perl`的正则表达式常放在两个斜线之内：`/正则匹配语句/`（事实上，这是`m//`的缩写形式），匹配成功返回真，失败返回假

# `.`：点号，匹配任意单个字符（换行符除外），匹配点号本身使用`\.`
# `*`：星号，匹配其前面字符任意多次（包括0次），`.*`表示匹配任意字符任意多次
# `+`：加号，匹配其前面字符一次或一次以上（至少1次）
# `?`：问号，匹配其前面字符0次或1次（可有可无）
# `\`：反斜线，专门用来转义，匹配反斜线本身使用`\\`

===通用量词===
# `{a,b}`：匹配其前面字符`a`到`b`次
# `{a,}`：至少匹配`a`次，没有上限
# `{a}`：刚好匹配`a`次

事实上，星号、加号和问号都只是通用量词的缩写

# `{0,}`：等价于星号
# `{1,}`：等价于加号
# `{0,1}`：等价于问号

===模式分组===
`Perl`使用圆括号进行模式分组，可以用`\1`、`\2`的形式引用这些模式分组<br>
要判断哪个括号是哪个分组，只需要计数左括号的序号即可

`Perl 5.10`加入了一种新的写法：`\g{N}`，其中`N`是想要反向引用的组号，其中`N`可以是负号<br>
`\g{N}`在匹配模式后面紧跟数字的情况下特别有效（小骆驼书说可以使用`\gN`的精简形式，但事实上是不支持的）<br>
因为`\g{N}`依据的是相对路径，所以就算再添加些模式分组也不会使之前的组号失效

===择一匹配===
`|`：竖线代表“或”，意为左右两边任意一边匹配都行

`( |\t)`：匹配单个空格或单个制表符

`( +|\t+)`：匹配一个以上的空格或一个以上的制表符

===字符集===
使用方括号包围，用来匹配单个字符，支持连字符`-`和取反符`^`

# `[abcwxyz]`：匹配这7个字符中的任意一个
# `[a-cw-z]`：使用连字符对上例的简写
# `[a-zA-Z]`：匹配所有52个英文字母中的任意一个字母
# `[\000-\177]`；匹配任意7位的ASCII字符
# `[^abc]`：匹配除a、b、c这三个字母以外的任意字符
# `[^n\-z]`：匹配除n、连字符、z以外的任意字符

某些常用字符集具有简写形式

# `\d`：表示任意数字，相当于`[0-9]`
# `\w`：表示单词字符，相当于`[a-zA-Z0-9_]`（这里假定单词只包含字母、数字和下划线）
# `\s`：匹配空白字符，包括换页、制表、换行、回车、空格，相当于`[\f\t\n\r ]`
# `\D`：匹配非数字字符，相当于`[^\d]`
# `\W`：匹配非单词字符，相当于`[^\w]`
# `\S`：匹配非空白字符，相当于`[^\s]`

其他常用匹配模式

# `[\da-fA-F]`：匹配十六进制数字（十六进制数字包括0-9、a-f、A-F）
# `[\d\D]`：匹配任意字符（包括换行符，而点号匹配的是除换行符以外的任意字符）
# `[^\d\D]`：什么也不匹配

===正则表达式匹配===
和`qw//`类似，`m//`也可以自定义定界符，比如写成：`m()`、`m<>`、`m{}`、`m[]`等<br>
但如果使用双斜线做定界符则可以省略m，即`m//`可以缩写成`//`

===正则匹配修饰符===
这些修饰符成组附加在正则表达式结尾定界符的后边，作用是改变默认的匹配规则

# `/i`：匹配时不区分大小写
# `/s`：使点号能够匹配换行符，亦即匹配任意字符
# `/x`：忽略匹配模式中的空白字符，如果要在其中匹配空白或制表符得使用反斜线

可以在一个模式匹配语句中同时写多个修饰符，如：`/isx`

===锚位符号===
# `^`：脱位符，标记字符串开头
# `$`：美元符，标记字符串结尾，同时也匹配字符串结尾的换行符
# `\b`：单词边界锚位，匹配任何单词的首尾
# `\B`：非单词边界锚位符，它能匹配所有`\b`不能匹配的位置

===绑定操作符===
`=~`即绑定操作符，它能使`Perl`拿右边的模式匹配左边的字符串，而非`$_`<br>

绑定操作符的优先级很高，很多时候都不需要使用括号

===使用变量===
可以在正则匹配模式里引用变量，使用`($变量名)`的形式即可

括号除了可以进行模式分组，还可以用来捕获变量，只是其引用的符号是`$1`、`$2`、`$3`等

捕获变量只在匹配成功时改写，如果匹配失败则不会改变上一次模式匹配捕获的内容

如果只想要括号作为分组标识符，而不进行变量捕获，则需要在左括号后面加上一个`?:`，如：`(?:)`<br>
{{{Perl
<pre class='brush: perl'>
my $names = "Fred or Barney";

if($names =~ m/(\w+) (?:and|or) (\w+)/){
	print "$1, $2\n";                  # 输出Fred, Barney
}
</pre>
}}}

====变量命名捕获====
`Per 5.10`引入了一个特殊的哈希表`%+`，键是捕获变量时使用的特殊标签，值是被捕获的串

命名格式：`(?<名称标签>匹配语句)`<br>
引用格式；`$+{名称标签}`<br>
{{{Perl
<pre class='brush: perl'>
my $names = "Fred and Barney";

if($names =~ m/(?<name1>\w+) (?:and|or) (?<name2>\w+)/){
	print "$+{name1}, $+{name2}, $1, $2\n"                # 输出Fred, Barney, Fred, Barney
}
</pre>
}}}
尽管使用了命名捕获，但原来的`$1`、`$2`等标识符并未失效

引入命名捕获以后，原来的`\g{N}`也可以改写成`\g{名称标签}`了<br>
{{{Perl
<pre class='brush: perl'>
my $names = "Fred Flinstone and Wilma Flinstone";

if($names =~ m/(?<last_name>\w+) and \w+ \g{last_name}/){
	print "$+{last_name}\n";                              # 输出Flinstone
}
</pre>
}}}
此外，`\k<名称标签>`等效于`\g{名称标签}`

====自动匹配变量====
# `$&`：保存字符串匹配上的部分
# `$``：保存匹配段落之前略过的部分
# `$'`：保存匹配段落之后，那些剩下的、从未匹配到的部分<br>
{{{Perl
<pre class='brush: perl'>
my $string = "Hello there, neighbor";

if($string =~ m/\s(w+),/){
	print "($`)($&)($')\n";                   # 输出(Hello)( there,)( neighbor)
}
</pre>
}}}
但有一个不好的消息，使用自动匹配变量会严重拖慢其他正则表达式的运行速度

===正则优先级===
# 第一级别：`(...)`、`(?:...)`、`(?<名称标签>...)`
# 第二级别：`*`、`+`、`?`、`{a,b}`
# 第三级别：`|`
# 第四级别：基本的元素

===模式测试程序===
{{{Perl
<pre class='brush: perl'>
#!/usr/bin/perl

while(<>){
	chomp;
	if(/需要测试的匹配语句/){
		print "Matched : |$`<$&>$'|\n";
	}
	else{
		print "No match : |$_|\n";
	}
}
</pre>
}}}
----
<red>date</red> : 2011-05-21
----
