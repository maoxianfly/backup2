%title 基础语法

[[../../../index|首页]] - [[../index|Perl]] - [[index|Base]]
==基础语法==
----
<red>重要</red>：`Perl`有一个理念是，如果去掉括号不影响意图，那么括号就是可以省略的

对于位数很多的数字，可以插入下划线，如：`61298040283768`可以写成`61_298_040_283_768`

* `0`：八进制
* `0x`：十六进制
* `0b`：二进制（这是`Perl`所特有的数据前缀）

`Perl`引入了`FORTRAN`的乘幂操作符，如：`2 ** 3`代表2的3次方

`单引号`字符串允许换行，只支持反斜线和单引号这两个转义字符，且不能使用变量

`双引号`和单引号基本上没有区别，只是反斜线支持更多转义字符，且可以在其中引入变量

`Perl`特有的转义字符列表

# `\e`：ESC
# `\cC`：控制符，这儿表示同时按下`Ctrl`和`C`键的返回码
# `\l`：将下一个字符转成小写
# `\L`：将到`\E`为止的所有字符转成小写
# `\u`：将下一个字符转成大写
# `\U`：将到`\E`为止的所有字符转成大写
# `\Q`：将到`\E`为止的非单词字符加上反斜线
# `\E`：作为上述几个转义字符的结束标志

`点号`：连接两个字符串<br>
`x`：重复连接N次，如：`"hello" x 3`将得到`"hellohellohello"`，而`5 x 4`将得到`5555`（注意不要和乘法运算符`*`混淆）

`Perl`的数字和字符串会根据语境自动转换，使用时不需要关心太多细节<br>
如：`"z" . 5 * 7`将得到`"z35"`
----
开启`Perl`内置警告信息的几种方法：

# 在运行时加`-w`选项，如：`perl -w app.pl`
# 在源文件第一行加上`-w`选项，如：`#!/usr/bin/perl -w`
# 在源文件中加上一句：`use warnings;`
# 在源文件中加上一句：`use diagnostics;`，这将显示更为详细的警告信息
----
`Perl`的变量标识符前缀是美元符：`$`<br>
支持`C语言`里面的双目赋值运算符，但以下两个是`Perl`特有的；
# `.=`：追加操作符，如`$str .= "hello"`表示在`$str`原有基础上连接上一个`"hello"`
# `**=`：乘幂操作符，如`$num **= 3`表示将`$num`自乘三次

输出信息使用`print`，如：<br>
{{{Perl
<pre class='brush: perl'>
print "The answer is ";
print 6 * 7;
print ".\n";
</pre>
}}}
以上语句与`print "The answer is ", 6 * 7, ".\n";`等价，输出结果是：`The answer is 42.`

为避免`print`在截取变量名时出现歧义，可以像`SHELL`一样使用花括号将变量名围起来，如：`${str}`

`比较运算符`列表：
| 相等     | == | eq |
| 不相等   | != | ne |
| 小于     | <  | lt |
| 大于     | >  | gt |
| 小于等于 | <= | le |
| 大于等于 | >= | ge |

`Perl`的`if语句`与C语言大体一致，但`else`程序块的花括号界限符是必须要写的

`Perl`没有`布尔`数据类型，判断真假的规则与其他语言一样，但有一些不同点：
# `'0'`：只有一个0字符的字符串会被转换成数字0，所以它是代表假的，这也是`Perl`里面唯一为假的非空字符串
# 如果需要判断的既不是数字也不是字符串，则会先自动转换成数字或字符串，然后再进行判断

获取用户输入：
# `<STDIN>`：获取输入直到换行符为止，其返回的字符串一般都会在最末尾跟上一个换行符
# `chomp`：去掉字符串末尾的换行符，但只能去掉一个，可以加括号也可以不加，返回值是移除的字符个数，用法如下：<br>
{{{Perl
<pre class='brush: perl'>
$text = <STDIN>;
chomp($text);
</pre>
}}}
上述两行也可以写作一行：`chomp($text = <STDIN>);`

`undef`：一个特殊的内置标量，当一个变量没有赋值就直接使用，那么这个变量的初值就自动赋值为`undef`，作为数字使用时代表0，作为字符串使用时代表一个空字符串 。可以显式给一个变量赋值为`undef`，如：`$num = undef;`

`defined()`：传入一个变量，如果已定义则返回真，如果是`undef`则返回假

===数组===
`Perl`的数组元素并不限定必须是同一种类型

允许在定义了一个数组后再行定义一个同名的变量，并不会出错

数组下标值可以是小数，`Perl`会自动截取其整数部分

如果下标值超出数组大小，并不出错，其对应值将会是`undef`

`Perl`数组不限大小，可以根据需要自动扩容，所以可以直接使用索引值超过数组尾端的元素，而其中间增补的元素都将默认赋值为`undef`

数组最后一个元素的索引值有一个特殊的代替符：`$#数组名`

`Perl`同样支持负数索引，最后一个元素的索引值是`-1`，倒数第二个是`-2`，依此类推

===列表===
`Perl`的列表相当强大和灵活，具体特性如下：

# `(1, 2, 3)`：包含1、2、3这三个数字的列表
# `()`：空列表
# `(1..100)`：从1到100的100个整数
# `(1.2..5.7)`：小数部分会去掉，相当于`(1..5)`，也就是`(1, 2, 3, 4, 5)`
# `(0, 2..5, 10)`：相当于`(0, 2, 3, 4, 5, 10)`
# `($m..$n)`：由`$m`和`$n`的值动态指定范围
# `($a + $b, $c + $d)`：包含两个数据的列表
# `(1, 3, "Ruchee", "look")`：列表可以包含任意数据类型

`qw()`：列表的简写形式，意为“quoted word”（加上引号的单词）<br>
所以`("abc", "look", "me")`与`qw( abc look me )`等价<br>
但是`qw列表`不支持一般转义字符，不能像普通列表一样引用变量

`qw列表`支持自定义定界符，并不只有小括号一种：

* `qw! abc look me !`
* `qw/ abc look me /`
* `qw# abc look me #`
* `qw( abc look me )`
* `qw{ abc look me }`
* `qw[ abc look me ]`
* `qw< abc look me >`
以上几种写法都是合法的，且允许转义所使用的定界符，如：`qw! Yahoo\! Google !`

====列表的赋值====
# `($a, $b, $c) = ("abc", "look", "me")`：按顺序依次把右边列表的元素赋值给左边列表的变量
# `($a, $b) = ($b, $a)`：互换两变量的值
# `($arr[0], $arr[1]) = ($arr[1], $arr[0])`：互换两数组元素的值

建立字符串数组的两种简便方法：<br>
# `($arr[0], $arr[1]. $arr[2]) = qw! abc look me !`：一个一个赋值
# `@arr = qw! abc look me !`：使用`@`符引用整个数组集体赋值 

其他示例：<br>
# `@arr = ()`：空列表
# `@arr = 1..1e2`：包含100个元素的列表
# `@arr2 = (@arr, undef, @arr)`：包含201个元素的列表
# `@arr3 = @arr`：将`arr`数组中的列表复制到`arr3`数组

===pop and push===
`Perl`并不像C语言一样擅长于索引操作，更多情况下是使用`pop`和 `push`

`pop(@arr)`：也可以不加括号`pop @arr`，作用是弹出目标数组最后一个元素，并将这个元素的值返回

`push(@arr, 2)`：同样可以不加括号，作用是向目标数组末尾新增一个值为2的元素<br>
`push @arr, 1..10`：向目标数组末尾新增10个新元素<br>
`push @arr, @arr2`：将`arr2`数组附加到目标数组末尾

`Perl`的强大之处在于，不仅可以在数组最右端直接操作，而且同样可以在最左端直接操作

`shift`：使用方法和`pop`类似，作用是弹出数组第一个元素<br>
`unshift`：对应于`push`，功能是向数组最左端插入元素

===数组内插===
可以将数组以`@arr`的形式放置在双引号字符串内，这将自动将数组的全部元素自动载入相应位置

如果要遇到方括号引起歧义的地方，可以使用反斜线转义（好像不论在哪个地方，只要如果有可能出现歧义就都可以使用转义字符来解决）

===foreach循环===
使用方式：`foreach 控制变量 (列表或数组)`<br>
{{{Perl
<pre class='brush: perl'>
# 第一种方式
foreach $a (qw/ abc look me /){
	print "$a\n";
}

# 第二种方式
@arr = qw/ abc look me /;
foreach $a (@arr){
	print "$a\n";
}
</pre>
}}}
可以在循环过程中修改控制变量的值，这将同步修改掉列表或数组中对应元素的值

如果省略了`控制变量`，则`Perl`会默认使用`$_`来代指<br>
{{{Perl
<pre class='brush: perl'>
# 将依次输出No.1至No.10
foreach (1..10){
	print "No.$_\n";
}

# 就连print都可以省略参数
$_ = "Ruchee\n";
print;  # 等同于 print "Ruchee\n";
</pre>
}}}

===翻转数组或列表===
`reverse(@arr)`：返回将目标数组翻转后的新数组，但原数组并没有被改变

一般可以这样使用：`@arr = reverse @arr;`

===对数组或列表进行排序===
`sort(@arr)`：默认按ASCII字符集排序，返回排序后的新数组，但原数组并没有被改变

`@arr = reverse sort @arr`：将目标数组反向排序

===Perl的上下文语境===
`@arr`：这个符号不一定总是代表一个数组的全体，它也可能代表的是该数组中元素的个数<br>
{{{Perl
<pre class='brush: perl'>
@arr = qw! abc look me !;
@arr = sort @arr;   # 这儿的@arr代表数组全体
$num = 12 + @arr;   # 这儿的@arr代表数组元素个数，值为3

@list = @arr;       # 这儿的@arr代表数组全体
$n = @arr;          # 这儿的@arr代表数组元素个数，值为3
</pre>
}}}

`@arr = reverse qw! abc look me !;`：将得到`me, look, abc`<br>
`$arr = reverse qw! abc look me !;`：将得到`emkoolcba`

可以使用伪函数`scalar`来强制切换标量上下文：<br>
{{{Perl
<pre class='brush: perl'>
@arr = qw! abc look me !;

print "It have ", @arr, " words!\n";   # 错误，这将输出：It have abclookme words!
print "It have ", scalar @arr, " words!\n";   # 正确，这将输出：It have 3 words!
</pre>
}}}
----
===子程序===
子程序即自定义函数，只是为了区别内置函数所以一般不称其为函数<br>
`Perl`的子程序不需要事先声明，如果有两同名函数，则后者将覆盖前者<br>
定义方法：`sub 子程序名 {子程序体}`<br>
调用方法：`&子程序名`或`&子程序名(参数表列)`

`Perl`子程序没有“有返回值”和“无返回值”之分，最后一次运算的结果会被自动当成返回值

`Perl`的程序调用相当古怪，它传递参数时不需要指定形参名，而是使用一个内置的`@_`数组或`$_`数组来存储所有的参数<br>
`@_[0]`或 `$_[0]`代表第一个参数，`@_[1]`或`$_[1]`代表第二个参数，依此类推（虽说两种写法都可以，但一般用`$_`来引用单个的参数，而用`@_`来引用整个参数表列）<br>
多余的参数会被忽略，参数不足则会被自动赋值为`undef`<br>

一个典型的求取最大值的子程序写法：<br>
{{{Perl
<pre class='brush: perl'>
# 子程序定义
sub max{                   # 这儿不需要像C语言一样声明形参列表
	if ($_[0] > $_[1]){    # 直接引用内置数组来获取参数
		$_[0];
	}
	else{
		$_[1];
	}
}                          # 没有使用return语句，最后一次执行语句的结果即为返回值

# 子程序调用
$num = &max(10, 15);       # 参数刚好，结果为15
$num = &max(10, 15, 25);   # 参数过多，25将被抛弃，不影响结果 
$num = &max(10);           # 参数不足，第一个参数是10，第二个参数默认赋值为undef，结果为10
</pre>
}}}

===子程序中的私有变量===
借用操作符`my`可以在子程序范围内创建私有变量，一般其用法如下：<br>
`my($a, $b) = @_`，作用是将传递给子程序的参数依次赋值给私有变量`$a`和`$b`

一个可以接受任意个参数的求取最大值的子程序（使用了“高水线”算法）：<br>
{{{Perl
<pre class='brush: perl'>
# 子程序定义
sub max{
	my($max_num) = shift @_;      # 预设最大值为第一个参数
	
	foreach (@_){                 # 遍历比较参数列表中的其他参数
		if($_ > $max_num){        # 如果有比预定值大的就覆盖
			$max_num = $_;
		}
	}
	$max_num;                     # 最后返回的就是整个参数列表中值最大的参数
}

# 子程序调用示例
print &max(3, 5, 10, 4, 6);       # 结果为10
</pre>
}}}
`my()`并不仅限于子程序，它可以在任意语句块中使用，可以不使用括号，但下面这两个语句有着截然不同的含义<br>
# `my($num) = @_;`：这是将`@_`数组的第一个元素赋给`$num`，得到的是只有一个元素的列表
# `my $num = @_;`：这是将`@_`数组元素的个数赋给`$num`，得到的是一个单独的变量
区别在于，不使用括号只能只能声明一个变量，而使用括号可以同时声明多个变量

使用编译命令`use strict;`可以检测程序中变量定义的一些问题

===return操作符===
一旦符合条件， `return`就会立即返回，和C语言一样<br>
但`Perl`不会像C语言一样滥用`return`语句，因为默认最后一次执行结果就是返回值，所以`return`一般只用在需要及时停止后续运算之时

下面是一个在列表中查找字符串的子程序，其中使用了`return`：<br>
{{{Perl
<pre class='brush: perl'>
# 子程序定义
sub find{
	my($what, @array) = @_;          # 将目标字符串赋给$what，将目标列表赋给@array
	
	foreach (0..$#array){            # 从下标0遍历到最末
		if($what eq $array[$_]){
			return $_;           # 只要找到就马上返回其所在的下标值，不再进行后续查找
		}
	}
	-1;                          # 没有找到则返回-1
}

# 子程序调用
my @names = qw/ abc look ruchee me /;
print &find("ruchee", @names);        # 结果为2
</pre>
}}}

===省略&号===
如果子程序在调用之前定义，则可以省略`&`号，直接使用形如`print max(10, 15);`的形式<br>
甚至连括号都可以省略，只要不影响语意：`print max 10, 15;`

省略`&`号意思就是让`Perl`把你自定义的子程序当成内置函数来调用，所以如果有同名的内置函数，那就必须得使用`&`号，不然是无法调用到自定义的子程序的

一般情况下，凡是自定义子程序都应该使用`&`号！不仅保证调用正确，还便于代码的维护

===非标量返回值===
子程序不仅仅可以返回一个单独的变量值，而且还可以返回一个数组或列表，下例扩展了自增运算符`..`<br>
{{{Perl
<pre class='brush: perl'>
# 子程序定义
sub list{
	if($_[0] < $_[1]){
		$_[0]..$_[1];            # 如果第一个参数较小，则按常规方法处理
	}
	else{
		reverse $_[1]..$_[0];    # 如果第二个参数较小，则从第二个参数向第一个参数递增，然后翻转返回
	}
}
</pre>
}}}

===持久性私有变量===
使用`state`关键字可以使每次子程序调用结束后保留指定的变量值，相当于C语言里面的`static`静态变量

使用`state`时一定要确保在源文件里加上一句`use 5.010;`，否则系统不能识别该关键字（加上这样的声明语句是告诉`Perl`解释器，本程序需要使用高于指定版本的高级特性）
----
<red>date</red> : 2011-05-15、2011-05-16、2011-05-17、2011-05-19、2011-11-15、2012-08-18合并整理
----
