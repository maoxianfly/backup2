%title Haskell基础语法

[[../../../index|首页]] - [[../index|Haskell]] - [[index|Base]]
==Haskell基础语法==
----
===运算符===

具有`&&`、`||`、`not`等逻辑运算符

`==`表示相等，`/=`表示不等

没有`+=`、`-=`等复合运算符

具有`+`、`-`、`*`、`/`运算，支持乘幂运算符`^`，但不支持取余运算符：`%`

对于`List`和`字符串`，可以使用`++`进行连接操作

`++`不适用于处理元素过多的大`List`或大字符串，因为`++`运算符会遍历整个左边的`List`，当左边的`List`很大时会存在效率问题

对于上面这种情况，应该使用 `:` 前插运算符在这个`List`的前端进行插入，如：`5 : [1, 2, 3, 4, 5]` --> `[5, 1, 2, 3, 4, 5]`

事实上，`[1, 2, 3]`也只不过是`1 : 2 : 3 : []`的语法糖

使用两个感叹号 `!!` 以索引的方式取得`List`的元素值，下标从`0`开始，如 `"Ruchee" !! 2`将得到`c`

在智能表中，可以使用 `_` 来代表一个永远也不会去用到的变量
----
===控制语句===

`Haskell`的`if`语句必须带有`else`分支，所以任何一个`if`语句都会返回一个结果，而不会像命令式语言一样有可能跳过执行

`Haskell`的每一个函数和表达式都将返回一个结果，这是强制性的
----
===函数===

命令式语言与函数式语言函数书写格式的简单区别如下

命令式：`函数名` + `括号` + `由逗号分隔的参数表列`，如 `max(100,101)`

函数式：`函数名` + `空格` + `由空格分隔的参数表列`，如 `max 100 101`

`命令式`函数的标志性符号是`括号`，而函数式函数的标志性符号是`空格`

`Haskell`的函数分`中缀`和`前缀`两种形式，常见为`前缀`

`Haskell`中，函数拥有最高的优先级：`succ 9 + max 5 4 + 1`等价于`(succ 9) + (max 5 4) + 1`，结果都为`16`

鉴于函数调用拥有最高优先级的特性，`succ 9 * 10`将取得`100`，而`succ (9 * 10)`才会取得`91`

对于有两个参数的函数调用，既可以用前缀形式，也可以用中缀形式，如`div 92 10`可写成`92 ```div``` 10`

`Haskell`函数定义的基本形式：`函数名` `参数表列` `等于号` `函数体`，形如 `func1 x = if x > 10 then x else x*2`

一般在函数名最后添加一个单引号来表示一个稍经修改但差别不大的函数

没有参数的函数其实就是一种“`定义`”，一旦定义，则值就不可再修改

`特别注意`：`函数`和`定义`的首字母不能用大写，否则将编译出错

`Haskell`的函数声明不分先后，这和`C`系语言有很大区别
----
===List表===

`Haskell`的`List`相当于其他语言里的`数组`，可以存放多个相同类型的元素，如：`[1, 2, 3]`

`字符串`事实上就是一组字符类型的`List`，如`hello`其实就是`['h', 'e', 'l', 'l', 'o']`的`语法糖`

凡可以处理`List`的函数都可以用来处理字符串

`List`支持无限嵌套，但必须确保所嵌套的`List`保持相同的类型

当`List`内装有可比较的元素时，`List`之间可以直接比较大小，依据是字典顺序

`List`有以下几个常用函数，其中`head`与`tail`是一对，`last`与`init`是一对：

# `head`：返回`List`的首个元素，如 `head [3, 2, 1]`得`3`
# `tail`：返回`List`除去首元素以外剩余的部分，如 `tail [3, 2, 1]`得`[2, 1]`
# `last`：返回`List`的最后一个元素，如 `last [3, 2, 1]`得`1`
# `init`：返回`List`除去尾元素以外剩余的部分，如 `init [3, 2, 1]`得`[3, 2]`

不要将`head`、`tail`、`last`、`init`用在空`List`上，这种类型的错误不会在编译阶段被捕获，所以要特别注意

其他常用函数：

# `length`：返回`List`的长度，如 `length [3, 2, 1]`得`3`
# `null`：检测`List`是否为空，空则返回`True`，非空返回`False`
# `reverse`：反转`List`，如 `reverse [3, 2, 1]`得`[1, 2, 3]`
# `take`：返回`List`中指定的前`N`个元素，如 `take 2 [3, 2, 1]`得`[3, 2]`
# `drop`：删除`List`中指定的前`N`个元素，然后返回剩余的部分，如 `drop 1 [3, 2, 1]`得`[2, 1]`
# `maximum`：返回`List`中最大的元素值，如 `maximum [3, 2, 1]`得`3`
# `minimum`：返回`List`中最小的元素值，如 `minimum [3, 2, 1]`得`1`
# `sum`：返回`List`中所有元素值的和，如 `sum [4, 3, 2, 1]`得`10`
# `product`：返回`List`中所有元素的积，如 `product [4, 3, 2, 1]`得`24`
# `elem`：判断某元素是否包含于目标`List`，返回`True`或`False`，如 `elem 3 [3, 2, 1]`得`True`
----
===自动区间===

使用连续的两点 `..` 来快捷获得指定区间：

# `[1 .. 4]`得到`[1, 2, 3, 4]`
# `['a' .. 'd']`得到`"abcd"`

也可以声明步长，按指定的步长进行增长：

# `[2, 4 .. 8]`每次增`2`，得到`[2, 4, 6, 8]`
# `[3, 6 .. 12]`每次增`3`，得到`[3, 6, 9, 12]`

自动区间默认是增`1`的，所以要得到`10`到`1`，不能使用`[10 .. 1]`，而应该写成`[10, 9 .. 1]`

由于浮点数的不精确性，所以应避免在步长控制中使用浮点数

步长控制可以不设上限，然后使用`take`来截取，如 `take 3 [1, 3, ..]`得`[1, 3, 5]`

`cycle`：接受一个`List`作参数，然后返回一个无限循环该`List`的`List`，可以使用`take`来按需截取

如 `take 7 (cycle [1, 2, 3])`得`[1, 2, 3, 1, 2, 3, 1]`

`repeat`：接受一个单一值作参数，然后返回一个无限包含该值的`List`，同样使用`take`来截取

如 `take 3 (repeat 'a')`得`"aaa"`

`replicate`：返回包含指定个某元素的`List`，这就不需要使用`take`来完成截取任务了

如 `replicate 3 10`得`[10, 10, 10]`

`cycle`只接受`List`作参数，而`repeat`和`replicate`既可接受单元素，也可接受`List`，`cycle`是循环返回，而后两者是重复返回，这是有差异的

# `cycle [1, 2]` --> `[1, 2, 1, 2, 1, 2 ..]`
# `repeat [1, 2]` --> `[[1, 2], [1, 2], [1, 2] ..]`
# `replicate 3 [1, 2]` --> `[[1, 2], [1, 2], [1, 2]]`
----
===智能表===

`Haskell`中的`List Comprehension`是真正的数学公式语言化，直截了当，清晰易懂

`List Comprehension`的基本形式是`[` `所求变量` `|` `限制条件1` `,` `限制条件2` `,` `...` `]`

比x如想取`0`到`100`中，大于`12`并小于`22`的所有偶数，可以这样写：`[x*2 | x <- [0 .. 50], x >= 12, x <= 22]`

`List Comprehension`支持多重限制条件，如 `[[x | x <- y, even x] | y <- z]`
----
===Tuple元组===

`Tuple`中的项不要求是同一类型，可以往`Tuple`中存储多类型项的组合

`Tuple`使用小括号包围，每个不同长度或不同元素类型的`Tuple`都是一个单独的类型，定义以后不允许再行添加

可以有单元素的`List`，但不允许有单元素的`Tuple`

含两个元素的`Tuple`叫`序对`，多于或等于三个的依次叫`三元组`、`四元组`

`Tuple`也可以比较大小，但进行比较的两`Tuple`元素个数必须相等

`Tuple`常用函数：

# `fst`：返回一个序对的首项（只支持对序对进行操作），如 `fst (5, 6)`得`5`
# `snd`：返回一个序对的尾项，如 `snd (5, 6)`得`6`
# `zip`：接受两个`List`作参数，返回一个组合后的`List`，其元素项是两`List`各元素两两组合而成的`Tuple`序对，如两参数长度不等，则较长的`List`会自动截断，剩余部分不作处理，如 `zip [1 ..] ["one", "two"]`得`[(1, "one"), (2, "two")]`
----
===类型系统===

`Haskell`是静态类型的，包括变量和函数都有类型，类型名首字母大写

以下是几个常见类型：

# `Int`：表示整数，有一定的上下界
# `Integer`：也表示整数，但它是无界的，只是效率没`Int`高
# `Float`：单精度浮点数
# `Double`：双精度浮点数
# `Bool`：布尔值，只有`True`和`False`两种取值
# `Char`：字符型，`[Char]`与`String`等价

跟`List`不同，每个不同的`Tuple`都是不同的类型

函数的类型声明：`函数名` `::` `第1个参数的类型` `->` `第2个参数的类型` `->` `...` `->` `返回值的类型`

如 `add` `::` `Int -> Int -> Int -> Int`，最后一个代表返回值的类型

`Haskell`中有类型变量的说法，类似于其他语言的`泛型`，一般使用单个字母命名，如`a`、`b`等

`Haskell`中的`类型类`则类似于`Java`中的`接口`，用来规范类型的行为

以下是几个基本的类型类：

# `Eq`：包含可判断相等性的类型，基本实现函数是`==`和`/=`
# `Ord`：包含可比较大小的类型，基本实现函数有`<`、`>`、`<=`、`>=`等
# `Show`：其成员为可用字符串表示的类型来看，基本实现函数是`show`
# `Read`：这是与`Show`相反的类型类，可以将字符串转为`Read`的某成员类型，基本实现函数是`read`
# `Enum`：其成员都是连续的类型，也就是可枚举的类型，如`()`、`Bool`、`Char`、`Ordering`、`Int`、`Integer`、`Float`、`Double`
# `Bounded`：其成员都有一个上限和下限
# `Num`：表示数字的类型类，其成员类型都具有数字的特征，包含所有的数字，包括实数和整数
# `Integral`：也是表示数字的类型类，但其只包含整数，包括的类型有`Int`和`Integer`
# `Floating`：仅包含浮点类型的类型类，包括`Float`和`Double`
----
<red>date</red> : 2012-01-17、2012-01-18、2012-01-20、2012-01-21
----
