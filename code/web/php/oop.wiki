%title 面向对象编程

[[../../../index|首页]] - [[../index|Web]] - [[index|PHP]]
==面向对象编程==
----
===基本概念===

类的实例化语法：`$obj = new cl_name(构造函数参数列表)`

`PHP`有一个特殊的指针`$this`，用来在类的内部访问该类的属性，如 `$this->name = $getName`（注意，`->`后面的属性名不需要带美元符）
----
===内置成员函数===

# `__construct()`：构造函数
# `__destruct()`：析构函数，不允许带参数
# `__clone()`：对象克隆
# `__toString()`：将类转换成字符串
----
===访问权限===

其他很多面向对象语言的默认访问权限是`private`，但`PHP`默认为`public`

至于`protected`与`private`的用法，`PHP`与其他面向对象语言没什么区别
----
===继承===

`PHP`的继承关键字是`extends`，如 `class B extends A { ... }`

父类的属性和方法在子类中访问权限的变化

# `public` -> `public`
# `protected` -> `protected`
# `private` -> 不能被继承

`PHP`的面向对象毕竟是后面才加入的，很多有用的东西都还没有，显得很残缺，比如`继承`直接就一个`public`继承，没有`protected`和`private`继承

子类可以重写父类已有的属性和方法，如果需要引用父类属性或方法，使用关键字`parent`，如 `parent::getName()`

关键字`final`的作用：将`final`添加到类定义的前面，则该类不允许被继承；将`final`添加到方法定义的前面，则该方法不允许被重载

注意，`final`只能用于类定义和方法定义，不能用于类的属性

和`Java`一样，`PHP`使用接口代替多重继承，使用方法也一样，使用的关键字是`interface`和`implements`
----
===面向对象高级特性===

可以在类里面使用关键字`const`定义常量，然后就可以直接通过类名引用该常量了，如 `类名::常量名`

还可以在类里面使用关键字`static`定义静态方法，这样的方法可以直接通过类名来调用，如 `类名::静态方法名()`

需要注意的是，静态方法中不允许使用`$this`指针
----
===静态成员===

`静态方法`只能访问类的`静态属性`，不能访问类的`普通属性`，`静态方法`中不能使用伪变量`$this`

`静态属性`和`静态方法`又称为`类属性`和`类方法`，类的所有对象都可以访问到表现一致的属性和方法

官方手册上说不能通过对象来访问其`静态属性`，但其给出的例子却表明，无论是`静态属性`还是`静态方法`，都可以通过对象来访问。经实测，给出的例子是对的。缘何手册会前后说法不一致呢？实在让人疑惑（使用的是`2012-05-31`版中文手册，查阅英文手册证实并没有翻译错）

`$this`指代的是当前对象，而`self`指代的是当前类

使用`$this->`时，后面的变量不需要美元符，但`self::`则需要美元符。如 `$this->name`、`self::$name`

访问被`static`修饰的属性和方法时，务必始终使用`::`操作符

但事实上，不论类（`原始类`）、对象、子类、子类的对象，都既可以通过`->`，也可以通过`::`访问到类（`原始类`）的`静态成员`，唯一不允许的情形是：用对象的`->`操作符访问`静态属性`，如 `$foo->static_name`是唯一不允许的情况

从`PHP 5.3`起，支持类名的动态调用，因为只有`静态成员`才能直接通过类名访问，所以这种动态调用也就只适用于`静态成员`了。如 `$cl_name = 'Foo';`、`$cl_name::$staticValue;`、`$cl_name::staticMethod();`
----
===常量属性===

`常量属性`使用`const`关键字修饰，和全局常量一样，一旦设置就不能再行改变

`常量属性`的命名不需要美元符，且按惯例要全部大写，如 `const NAME = 'Ruchee';`

和`静态属性`一样，官方说法是只能通过类直接访问，但实际情况是，类（`原始类`）、对象、子类、子类的对象都可以访问到类（`原始类`）的`常量属性`
----
===抽象类===

使用`abstract`关键字定义抽象类，抽象类不允许实例化，大多数情况下，抽象类至少要包含一个抽象方法

抽象方法不能含有具体的方法体，所以抽象方法在抽象类里面只是声明，而不是真正的定义

抽象类的每个子类都必须全部实现抽象类中的所有抽象方法，除非该子类也是抽象类

子类实现方法的访问控制级别不能比抽象方法的访问级别更严格，只能相等或放宽访问权限

子类实现方法的参数必须和抽象方法所声明的一样
----
===接口===

接口是纯粹的模板，只能定义功能，不能包含实现的内容，`PHP`使用关键字`interface`定义接口

任何实现接口的类都必须全部实现接口所定义的所有方法，除非该类声明为`abstract`

实现接口使用关键字`implements`

一个类最多可以同时继承一个父类和实现任意个接口，`extends`子句应该放置在`implements`子句之前，如：
{{{PHP
<pre class='brush: php'>
class ClassA extends ClassB implements IntA, IntB, IntC{
    ...
}
</pre>
}}}
----
===延迟绑定===

使用方法是在父类的`静态方法`中返回一个`new static()`，这将根据调用该方法的子类来产生一个该子类的实例，而不是父类的实例

`static`关键字不仅可以用于实例化对象，还和`self`、`parent`一样可以作为`静态属性`调用的标识符

在延迟绑定中，`static`类似于`self`，只是`static`指向的是被调用的类，而不是包含类
----
===拦截器===

`PHP`内置了几个拦截器方法，当满足特定的情况时会被自动调用

`__get()`会在访问未定义的属性时调用，并带一个包含有要访问的属性名称的字符串参数

`__set()`会在给未定义的属性赋值时调用，并带有设置的属性名和要设置的属性值两个参数

`__isset()`和`__get()`类似，当在一个未定义属性上调用`isset()`时会被自动调用

`__unset()`和`__set()`类似，当在一个未定义属性上调用`unset()`时会被自动调用

`__call()`会在调用未定义的方法时被自动调用，并带有调用的方法名和传递给该调用方法的所有参数

`__autoload()`会在实例化未知的类时被自动调用，可以在这个方法里面书写源代码文件的包含语句，以实现自动加载
----
===对象复制===

`$obj2 = $obj1`，表示的是`$obj2`和`$obj1`指向的是同一个对象，如果不想两者绑定就该使用关键字`clone`，如 `$obj2 = clone $obj1`

内置方法`__clone()`会在使用`clone`关键字时自动调用，可以在里面书写对象复制的具体规则

要注意的是，`__clone()`是在复制得到的对象上运行的，而不是在原始对象上运行

`clone`可以保证所有基本数据类型的属性被完全复制，而对于对象属性则依然复制的是引用，这就需要在`__clone()`方法中针对对象属性显式书写复制语句，如 `$this->obj = clone $this->obj`
----
<red>date</red> : 2012-06-22、2012-06-23、2012-09-06
----
