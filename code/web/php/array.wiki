%title 数组

[[../../../index|首页]] - [[../index|Web]] - [[index|PHP]]
==数组==
----
===基本特点===

`PHP`的数组既是`数组`也是`哈希`（`PHP`称为`关联数组`），也就是说数字索引和键值对共存

数组元素可以动态增添和删改，数字下标本质上只是伪装的字符串
----
===数字索引===

手动创建：`$arr = array('Ruchee', 'is', 'a', 'good', 'boy')`

自动创建：`$arr = range(1, 6)`，等价于 `$arr = array(1, 2, 3, 4, 5, 6)`

`range()`函数可以有第三个可选的参数，代表每次递增的步长

`range()`也可以用于字符：`$letters = range('a', 'z')`、`$some_letters = range('a', 'z', 2)`

`PHP`的数组同变量一样不需要事先声明，比如这么一句就代表创建了一个只有一个元素的数组：`$arr[0] = 'Only One'`

数组允许动态增加新的元素，其本质是以哈希表的形式进行新增，也就是说数字索引本质上是当作字符串进行处理的，所以索引值可以不连续，示例如下：

{{{PHP
<pre class="brush: php">
$arr = range('a', 'c');  // 现有的元素为'a'、'b'、'c'

$arr[4] = 'd';  // 在下标为4的位置新增了一个元素，注意，下标3没有设置

echo "$arr[3]\n";  //  错误，没有$arr[3]这个元素

echo "$arr[4]\n";  //  正确，下标4就是新增的元素'd'
</pre>
}}}
----
===关联数组===

创建关联数组：`$arr = array('a' => 'Ruchee', 'b' => 'boy')`

对于关联数组而言，除了可以使用`foreach`循环外，还可以使用`each()`和`list()`这两个函数

`each()`每次会返回一组键值对，其约定下标`'key'`或`0`代表键，下标`'value'`或`1`代表值，示例如下：

{{{PHP
<pre class="brush: php">
$arr = array('a' => 'Ruchee', 'b' => 'is', 'c' => 'boy');

while($elm = each($arr)){
	echo $elm['key'] . " => " . $elm['value'] . "\n";
	//  或者echo $elm[0] . " => " . $elm[1] . "\n";
}
</pre>
}}}

而`list()`的作用是对传给它的`数组`或`键值对`进行拆解，可用于实现并行赋值，示例如下：

{{{PHP
<pre class="brush: php">
$arr = array('a' => 'Ruchee', 'b' => 'is', 'c' => 'boy');

while(list($a, $b) = each($arr)){
	echo $a . " => " . $b . "\n";
}
</pre>
}}}

有一点需要注意的是，`each()`会记录数组循环指针的位置，所以在再一次遍历同一个数组时需要使用`reset()`将指针复位，示例如下：

{{{PHP
<pre class="brush: php">
while(list($a, $b) = each($arr)){
	echo $a . " => " . $b . "\n";
}

reset($arr);  // 将循环指针复位

while(list($a, $b) = each($arr)){
	echo $a . " => " . $b . "\n";
}
</pre>
}}}
----
===数组互操作===

数组之间允许相加，语法为 `$arr3 = $arr1 + $arr2`，规则如下：

# 如果两数组索引没有冲突则直接整合成一个数组
# 如果两数组存在相同的索引，则以`$arr1`为准，`$arr2`中凡是存在与`$arr1`重复的索引就会丢弃，只有不重复的索引才会被整合
# 注意，数组进行相加操作时，一律以`+`号左边的数组为准，右边数组有重复的索引是一律丢弃，而不是覆盖左边的数组

数组相加示例如下：

{{{PHP
<pre class="brush: php">
$a = range(1, 3);  //  1 2 3
$b = range(4, 7);  //  4 5 6 7

$c = $a + $b;      //  1 2 3 7
</pre>
}}}

数组可以使用的其他操作符如下：

# `==`：元素值和元素顺序相同（`array(1, 2) == array(1, '2')`）
# `===`：元素值、元素顺序与元素类型都相同
# `!=`：不符合`==`的情况
# `<>`：与`!=`一样
# `!==`：不符合`===`的情况
----
===多维数组===

多维数组的创建：`$arr = array(array(1, 2, 3), array('a', 'b', 'c'))`

二维数组的遍历示例：

{{{PHP
<pre class="brush: php">
$arr = array(array(1, 2, 3), array('a', 'b', 'c'));

// 第一种方法，使用多重foreach循环
foreach($arr as $key => $value){
	echo "子数组$key：\n";
	foreach($value as $k => $v){
		echo "$k => $v\n";
	}
}

// 第二种方法，使用多重for循环
for($i = 0; $i < 2; $i++){
	echo "子数组$i：\n";
	for($j = 0; $j < 3; $j++){
		echo "$j => {$arr[$i][$j]}\n";
	}
}
</pre>
}}}

一般情况下，使用`foreach`或`list()` & `each()`会更灵活
----
===数组排序===

函数：`sort()`

`sort()`会按`ASCII`码将元素值从小到大排序，所以大写字母一律排在小写字母的前面

如果数组是关联数组，则排序完成后，所有键名将被清除，原关联数组将变成数字索引

`sort()`有可选的第二个参数，可选值有：`SORT_REGULAR`（正常排序，默认值）、`SORT_NUMERIC`（当成数字）、`SORT_STRING`（当成字符串）

关联数组专用的两个排序函数

# `ksort()`：按键名排序（升序排列）
# `asort()`：按键值排序（升序排列）

逆向排序

# `rsort()`：按`ASCII`码值的大小逆向排序，关联数组的键名将被清空（降序排列）
# `krsort()`：按键名排序（降序排列）
# `arsort()`：按键值排序（降序排列）

自定义排序

# `usort()`：按自定义函数排序，排序结束后，关联数组的键名被清空
# `uksort()`：按自定义函数对键名排序
# `uasort()`：按自定义函数对键值排序

自定义排序主要用于多维数组，如果想要按`升序`排列，那么第一个参数小于第二个参数时必须返回一个小于`0`的值（一般返回`-1`），当两参数相等时必须返回`0`，当第一个参数大于第二个参数时必须返回一个大于`0`的值（一般返回`1`）

而如果想按`降序`排列，只需将`升序`排列中返回`1`与返回`-1`的逻辑互换即可

下面展示用自定义函数`升序`排列一个二维数组（`3`行`2`列），排序依据的是每个子数组的第`2`个元素值（第`2`列）：

{{{PHP
<pre class="brush: php">
$arr = array(array('a', 3),
			 array('b', 1),
			 array('c', 2));

// 自定义排序函数
function compare($x, $y){
	if($x[1] < $y[1]){
		return -1;
	}
	else if($x[1] > $y[1]){
		return 1;
	}
	else{
		return 0;
	}
}

// 应用自定义函数排序
usort($arr, 'compare');

// 输出排序结果
print_r($arr);
</pre>
}}}
----
===其他数组相关的函数===

# `count(数组名)`：统计数组元素的个数
# `shuffle(数组名)`：将数组元素的顺序随机打乱，如果是关联数组，则键名会被清空
# `array_push(数组名, 元素值1, 元素值2, ...)`：在数组末尾添加元素
# `array_pop(数组名)`：删除数组最后一个元素，并返回该元素的值
# `array_reverse(数组名)`：翻转一个数组，其返回的是一个原数组翻转过的副本，并不会修改原数组的值，支持关联数组
----
===将文件读入数组===

使用`file()`函数可以将整个文件读入一个数组，一个元素对应文件的一行，如 `$names = file("names.txt")`
----
<red>date</red> : 2012-06-17、2012-06-22
----
