%title 深入面向对象

[[../../../index|首页]] - [[../index|PHP]] - [[index|Base]]
==深入面向对象==
----
===静态成员===

`静态方法`只能访问类的`静态属性`，不能访问类的`普通属性`，`静态方法`中不能使用伪变量`$this`

`静态属性`和`静态方法`又称为`类属性`和`类方法`，类的所有对象都可以访问到表现一致的属性和方法

官方手册上说不能通过对象来访问其`静态属性`，但其给出的例子却表明，无论是`静态属性`还是`静态方法`，都可以通过对象来访问。经实测，给出的例子是对的。缘何手册会前后说法不一致呢？实在让人疑惑（使用的是`2012-05-31`版中文手册，查阅英文手册证实并没有翻译错）

`$this`指代的是当前对象，而`self`指代的是当前类

使用`$this->`时，后面的变量不需要美元符，但`self::`则需要美元符。如 `$this->name`、`self::$name`

访问被`static`修饰的属性和方法时，务必始终使用`::`操作符

但事实上，不论类（`原始类`）、对象、子类、子类的对象，都既可以通过`->`，也可以通过`::`访问到类（`原始类`）的`静态成员`，唯一不允许的情形是：用对象的`->`操作符访问`静态属性`，如 `$foo->static_name`是唯一不允许的情况

<red>题外话</red>：综上所述，`PHP`是要多奇葩就有多奇葩，这也无怪乎网上很多人批`PHP`是门烂得掉渣的语言，不得不说，确实很烂

从`PHP 5.3.0`起，支持类名的动态调用，因为只有`静态成员`才能直接通过类名访问，所以这种动态调用也就只适用于`静态成员`了。如 `$cl_name = 'Foo';`、`$cl_name::$staticValue;`、`$cl_name::staticMethod();`
----
===常量属性===

`常量属性`使用`const`关键字修饰，和全局常量一样，一旦设置就不能再行改变

`常量属性`的命名不需要美元符，且按惯例要全部大写，如 `const NAME = 'Ruchee';`

和`静态属性`一样，官方说法是只能通过类直接访问，但实际情况是，类（`原始类`）、对象、子类、子类的对象都可以访问到类（`原始类`）的`常量属性`（`-_-!`又一次奇葩）
----
===抽象类===

使用`abstract`关键字定义抽象类，抽象类不允许实例化，大多数情况下，抽象类至少要包含一个抽象方法

抽象方法不能含有具体的方法体，所以抽象方法在抽象类里面只是声明，而不是真正的定义

抽象类的每个子类都必须全部实现抽象类中的所有抽象方法，除非该子类也是抽象类

子类实现方法的访问控制级别不能比抽象方法的访问级别更严格，只能相等或放宽访问权限

子类实现方法的参数必须和抽象方法所声明的一样
----
===接口===

接口是纯粹的模板，只能定义功能，不能包含实现的内容，`PHP`使用关键字`interface`定义接口

任何实现接口的类都必须全部实现接口所定义的所有方法，除非该类声明为`abstract`

实现接口使用关键字`implements`

一个类最多可以同时继承一个父类和实现任意个接口，`extends`子句应该放置在`implements`字句之前，如：
{{{PHP
<pre class='brush: php'>
class ClassA extends ClassB implements IntA, IntB, IntC{
    ...
}
</pre>
}}}
----
===延迟绑定===

使用方法是在父类的`静态方法`中返回一个`new static()`，这将根据调用该方法的子类来产生一个该子类的实例，而不是父类的实例

`static`关键字不仅可以用于实例化对象，还和`self`、`parent`一样可以作为`静态属性`调用的标识符
----
===拦截器===

`PHP`内置了几个拦截器方法，当满足特定的情况时会被自动调用

`__get()`会在访问未定义的属性时调用，并带一个包含有要访问的属性名称的字符串参数

`__set()`会在给未定义的属性赋值时调用，并带有设置的属性名和要设置的属性值两个参数

`__isset()`和`__get()`类似，当在一个未定义属性上调用`isset()`时会被自动调用

`__unset()`和`__set()`类似，当在一个未定义属性上调用`unset()`时会被自动调用

`__call()`会在调用未定义的方法时被自动调用，并带有调用的方法名和传递给该调用方法的所有参数

`__autoload()`会在实例化未知的类时被自动调用，可以在这个方法里面书写源代码文件的包含语句，以实现自动加载
----
===对象复制===

`$obj2 = $obj1`，表示的是`$obj2`和`$obj1`指向的是同一个对象，如果不想两者绑定就该使用关键字`clone`，如 `$obj2 = clone $obj1`

内置方法`__clone()`会在使用`clone`关键字时自动调用，可以在里面书写对象复制的具体规则

要注意的是，`__clone()`是在复制得到的对象上运行的，而不是在原始对象上运行

`clone`可以保证所有基本数据类型的属性被完全复制，而对于对象属性则依然复制的是引用，这就需要在`__clone()`方法中针对对象属性显式书写复制语句，如 `$this->obj = clone $this->obj`
----
<red>date</red> : 2012-08-31、2012-09-05、2012-09-06、2012-09-07
----
