%title 指定位置1

[[../../../index|首页]] - [[../index|C/C++]] - [[index|Subject]]
==指定位置1==
----
===问题描述===

初始化一个`32`位的二进制数据，将其第`1`、`2`、`3`、`5`、`8`、`13`、`21`位置`1`
----
===问题求解===

题目给出的下标有一个明显的特点：后一个下标等于它前面两个下标的和，只要解决这个问题就迎刃而解

使用一个`while`循环，`a`为第`1`个下标，`b`为第`2`个下标，則第`3`个下标为`a + b`

事先使用一个中间变量`t`保存`a`的值，然后把`b`赋值给`a`，而将`b`的值改为`t + b`

这样`a`的值就总是题目所要求的下标，而`b`的值总是`a`后面的那个下标，这样循环补充和交换，问题解决

{{{C++
<pre class="brush: cpp">
#include <iostream>
#include <bitset>

using std::bitset;

int main(int argc, char **argv)
{
	// 定义一个空的32位bitset
	bitset<32> bi;
	
	// 事先定义三个需要用到的变量
	int a(1), b(2), t;

	while(a <= 21){
		// 置位语句写在最前，a中保存有需要置位的下标值
		b.set(a);
		
		// 事先保存a的值，留待后用
		t = a;
		// 将b的值赋给a
		a = b;
		// 将b的值赋为原来的a+b，使得b值为下一个要求的下标
		b += t;
	}
	
	// 输出检验
	std::cout << bi << std::endl;
}
</pre>
}}}
----
<red>date</red> : 2012-04-03
----
