%title 错误拾遗

[[../../../index|首页]] - [[../index|C]] - [[index|Other]]
==错误拾遗==
----
在两重循环里面引入临时的统计变量时，一定要记得在开始每一次外循环时清零，否则统计值会失去外循环的控制，导致查找错误都相当困难<br>
相关代码摘录：<br>
{{{
<pre class="brush: c;">
int i;    // 外循环标记
int j;    // 内循环标记
int sum;  // 临时统计变量

for(i = 0; i < num; i ++){
	sum = 0;   // 临时统计变量清零，很关键
	// 内循环
	for(j = i; j < num; j ++){
		sum += j;
		...
	}  // end for
}  // end for
</pre>
}}}
----
要判断某数是否能够完全平方，不能蛮干，应该使用下面的方式；<br>
{{{
<pre class="brush: c;">
#include <math.h>

long int num;   // 需要判断的数值
long int x;
x = sqrt(num);  // 开方后的数值

// 如果开方后的数再次平方还能等于原来的数，那就说明该数可以完全平方
// 因为如果不能完全平方，则开方后得到的数值就并非精确值，再次平方是无法再得到原值的
if((x * x) == num){
	...
}
</pre>
}}}

`重要`：上面的算法严格说来是错误的，因为`sqrt`返回的结果是双精度浮点型，既然是浮点数那就有可能出现误差

比如对`4`开方，本应该得到`2`，但因为浮点数的不精确，有可能得到的只是`1.9999`，这样`1.9999 * 1.9999`就不等于`4`了

正确的算法如下：
{{{
<pre class="brush: c">
#include <math.h>

long int num;     // 需要判断的数值
double x;
x = sqrt(num);    // 开方得到的数字

// floor函数返回的是不大于参数的最大整数，如floor(4.12) == 4
// 对于num == 4时，如果因为浮点数的不精确问题，x得到的是一个不精确的的值：1.9999
// 因为1.9999 + 0.5 > 2，所以floor(x + 0.5)依然还是等于2，而不是1
// 这样，就算出现精度问题，程序还是可以正常判断num是否为完全平方数
if(floor(x + 0.5) == x){
	...
}
</pre>
}}}
----
C语言不支持C++里面的引用，不要把这两语言搞混了

在使用`scanf`获取`double`类型数据的输入时，必须使用格式符`%lf`，不能使用`%f`
----
<red>date</red> : 2011-05-24、2011-05-26、2012-02-26
----
