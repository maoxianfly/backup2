%title 基础语法拾遗

[[../../../index|首页]] - [[../index|Lang]] - [[index|Erlang]]
==基础语法拾遗==
----
===数据类型===

`Erlang`拥有整数类型`Integers`，和`Python`一样，没有最大值的概念，这只取决于机器的可用内存有多大

`Erlang`可以自由定义和使用基数不为`10`的数值，规则就是使用 `Base#Value` 的形式来定义，`Base`介于`2 - 16`之间

表示整数`20`的几种等价表示方法：`2#10100`、`8#24`、`20`、`16#14`

浮点数`Float`和常规语言无异，支持科学计数表示法

`Erlang`没有单独用来表示布尔类型的布尔值或字符，但基元`true`和`false`的使用与布尔类型无异
----
===变量===

`Erlang`中，变量必须以`大写字母`开头（也可以用下划线开头，但一般只用于模式匹配），其他可用字符为`字母`、`数字`和`下划线`

`Erlang`的变量只允许赋值一次，以后就不能再行变更了，这称为`单次赋值`

基于这个特点，所以`Erlang`的函数调用都是`按值调用`的，不存在`引用调用`

所有变量都是`局部变量`，不存在`全局变量`

`Erlang`是动态类型的语言，变量的使用不需要声明

变量只能绑定一次，但也可以使用函数`f()`来解绑一个变量，但这个方法只能用于终端，在程序里使用是错误的
----
===基元atom===

`atom`相当于`C/C++`里面的`#define`，其唯一可用的操作就是比较，`atom`主要是受逻辑编程语言`Prolog`影响而引入的类型

`atom`的命名规则是以小写字母开头，或者以单引号包围，普通情况下可以使用`字母`、`数字`、`@`、`.`和`_`，而有单引号包围时则可以使用任意字符

这是几个合法的`atom`：`myname22`、`start_with_this`、`my@ruchee.com`、`'a space'`、`'{}#@\n\012--abc'`

基元与字符串具有本质的区别，系统保存有它的一个内部标识符，与其本身的大小无关，所以其比较操作相当高效
----
===元组tuple===

`Erlang`的元组使用大括号包围，可以保存任意数据类型，元素的索引从`1`开始，而不是`0`

当一个元组的第一个元素是一个基元时，称它为标记`tag`，`Erlang`使用这一惯例来表示不同类型的数据

在比较两个元组时，其首要的比较依据是`元素的个数`，当元素个数相等时，才会按`字典顺序`逐个元素比较
----
===列表list===

`Erlang`的列表使用中括号包围，同样可以保存任意数据类型，列表是函数式编程`递归`的核心

列表和元组的最大不同在于，列表可以无限分解成`头部`和`尾部`两部分，`第一个元素`为头部，`剩余部分`为尾部

一个列表的常规分解模式为 `List = [Element | List]`，如果最后一个尾部项是一个空列表，就说这是一个`结构良好`的列表

除极少部分特殊场合外，在`Erlang`中应尽量避免使用结构不良好的列表，否则将极难排查代码的错误

比较两列表时，首要的比较依据是`字典顺序`，这与元组的比较规则不同

`列表`有三个专用操作符：`[...|...]`、`++`、`--`，其中，前者称为`构造器`，后两者分别为列表相加和列表相减

`++`和`--`的结合性为`右结合`，所以`[1, 2, 3] -- [1, 3] -- [1, 2]`的结果是`[1, 2]`，而不是`[]`

要在一个列表的最前面添加一个元素，可以使用`构造器`，也可以使用`++`，但`构造器`效率更高，如 `[1 | [2, 3, 4]]`和`[1] ++ [2, 3, 4]`
----
===字符串===

`Erlang`没有字符串类型，表示字符串得使用一个由`ASCII`值组成的整数列表来实现，如 `[65, 66, 67]`表示字符串`"ABC"`

`$Character`的形式将返回该字符的`ASCII`值，如`$a`得到`97`，`$A`得到`65`，所以字符串`"ABC"`也可以用`[$A, $B, $C]`来表示

`Hello World`的表示方式为：`[$H, $e, $l, $l, $o, $ , $W, $o, $r, $l, $d]`

两相连字符串会被解释器自动拼合为一个字符串，如 `"Ruchee " "is " " good!".`将得到`"Ruchee is good!"`

由于电信应用并不依赖于字符串操作，所以`Erlang`的字符和字符串存储从来就没有高效过，推荐使用`二进制`类型来表示长字符串
----
===运算符===

`Erlang`支持的运算符：加`+`、减`-`、乘`*`、除`/`、整除`div`、取余`rem`，其中`div`和`rem`的操作数必须为整数

`Erlang`拥有现代化的与`and`、或`or`、异或`xor`、否定`not`等逻辑运算符

但`and`和`or`不支持短路逻辑，取而代之的是`andalso`和`orelse`

支持的比较运算符有以下几个

# `>`：大于
# `>=`：大于等于
# `<`：小于
# `=<`：小于等于（这个相当反人类，居然不是`<=`，而是`=<`）
# `==`：等于
# `/=`：不等于
# `=:=`：严格等于（又一反人类符号）
# `=/=`：严格不等于（同上）

数据类型的比较排序：`number` < `atom` < `reference` < `fun` < `port` < `pid` < `tuple` < `list` < `binary`

也就是说，任何`number`都比任何`atom`要小，而任何`tuple`也都小于任何`list`
----
===模式匹配===

`Erlang`的模式匹配其实就是一套与变量赋值有关的规则，在其他语言里，变量赋值很简单，但由于`Erlang`的变量具有`单次赋值`的特点，所以规则不少

模式匹配的一般规则是，先计算`=`号右边的`表达式`，然后用它的值去与`=`号左边的`模式`进行比较

`Erlang`的`=`号本质是模式匹配的`比较`操作，而不是`赋值`操作

`Erlang`模式匹配的三大用途：

# 变量赋值
# 控制程序执行流程
# 从复合数据类型中进行数据的提取

如果在元组里多次出现同一个变量，那这些变量所处位置对应的值必须也相等。如 `{A, A, B} = {1, 1, 2}.`

对于列表，一个`[...|...]`形式的列表必须匹配一个非空列表。如 `[Head|Tail] = [1, 2, 3].`，结果`Head.`为`[1]`，`Tail.`为`[2, 3]`

无论元组或列表，左边的模式与右边的表达式，其元素个数必须相等。如 `{A, B, C} = {1, 2, 3}.`、`[A, B, C] = [1, 2, 3].`

尽管`[A, B, C, D] = [1, 2, 3].`会因为元素个数不相等而匹配失败，但`[A, B, C | D] = [1, 2, 3].`是可以匹配成功的，此时`D.`为空列表

使用`_`通配符可以略过某些不想匹配的值，如 `{A, B, _} = {1, 2, 3}.`
----
===模块===

模块文件以`.erl`后缀结尾，文件名与模块名必须相同

`Erlang`注释以`%`开始，直到该行结尾，一般用两个百分号重叠使用：`%%`

函数由其`名字`、`元数`和定义所在的`模块`唯一标识，同一个模块中的函数，在调用之前不需要声明

在执行一个从模块中导出的函数时，必须进行代码的编译，编译后就可以像`demo:double(10).`这样从模块外部调用导出的指定函数了

一个典型的模块示例，该文件必须存储为`demo.erl`：
{{{Erlang
<pre class='brush: erlang'>
-module(demo).  %% 指定模块名称
-export([double/1]).  %% 声明导出的函数列表
 
%% 定义函数

double(Value) ->
	times(Value, 2).  %% 同一个模块的函数可以随意调用
times(X, Y) ->
	X * Y.
</pre>
}}}

常用模块指令

# `-module(m_name).`：指定模块名称
# `-export([导出函数列表]).`：声明导出的函数列表
# `-import(m_name, [导入函数列表]).`：从其他模块导入函数（`Erlang`社区不推荐过多地使用导入语句）
# `-compile(export_all).`：在编译阶段导出所有函数，多用于测试目的

也可以编写自己的模块指令，如 `-author(Ruchee)`，但用户自定义指令只能有一个参数

所有模块信息都可以通过调用每个模块都有的函数`m_name:module_info().`或在终端使用`m(m_name).`得到
----
===函数===

`Erlang`的函数名称就是一个`基元`，函数参数的个数称为`元数`，使用符号`->`分隔函数头和函数体，函数必须在模块中定义和单独编译

函数是以`分号`分隔开的一个或多个`语句`组成的，最后以`句点`结束，每个语句都有一个指定`参数模式`的头部和一个函数体

`函数体`由一个或多个以`逗号`分隔的表达式组成，函数的返回的是最后一个表达式的值

`Erlang`的函数有点像其他语言的`switch`语句，它是根据一个个`参数模式`来匹配调用的，只要一个匹配成功，余下的就不会再继续执行

下面是一个典型的`Erlang`函数，用于计算阶乘：
{{{Erlang
<pre class='brush: erlang'>
factorial(0) -> 1;  %% 语句1
factorial(N) ->  %% 语句2
	N * factorial(N-1);
</pre>
}}}
----
===常用内置函数（BIF）===

* `is_boolean().`：测试某个值是否为布尔类型，如 `is_boolean(false).`返回`true`
* `tuple_size().`：返回目标元组的元素个数，如 `tuple_size({abc, {def, 123}, ghi}).`返回`3`
* `length().`：返回目标列表的元素个数，如 `length([1, 2, 3, 4]).`返回`4`
* `element().`：获取元组指定下标的元素值，如 `element(2, {abc, {def, 123}, ghi}).`返回`{def, 123}`（下标从`1`开始）
* `setelement().`：修改元组指定下标的元素值，如 `setelement(2, {abc, {def, 123}, ghi}, test).`，结果为`{abc, test, ghi}`
----
===常用列表函数===

* `lists:nth().`：返回指定下标的元素值，如 `lists:nth(2, [1, 2, 3, 4]).`返回`2`
* `lists:last().`：返回列表最后一个元素，如 `lists:last([1, 2, 3, 4]).`返回`4`
* `lists:max().`：返回列表元素最大值，如 `lists:max([1, 2, 3, 4]).`返回`4`
* `lists:sum().`：列表元素求和，如 `lists:sum[1, 2, 3, 4].`返回`10`
* `lists:member().`：判断某元素值是否包含于目标列表当中，如 `lists:member(5, [1, 2, 3, 4]).`返回`false`
* `lists:delete().`：删除指定下标处的元素，如 `lists:delete(2, [1, 2, 3, 4]).`返回`[1, 3, 4]`
* `lists:sort().`：返回排序后的列表，按从小到大排序，如 `lists:sort([1, 3, 2, 4]).`返回`[1, 2, 3, 4]`
* `lists:reverse().`：返回翻转后的列表，如 `lists:reverse([1, 2, 3, 4]).`返回`[4, 3, 2, 1]`
* `lists:split().`：从指定下标处分割列表，返回的结果为一个元组，如 `lists:split(1, [1, 2, 3, 4]).`返回`{[1], [2, 3, 4]}`
* `lists:zip().`：接受两个列表作为参数，将各对应元素依次拆分再合并，返回一个元素值为元组的列表，如 `lists:zip([1, 2], [3, 4]).`返回`[{1, 3}, {2, 4}]`
----
<red>date</red> : 2012-04-17、2012-07-21、2012-10-09合并整理
----
