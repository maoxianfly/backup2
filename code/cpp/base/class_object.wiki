%title 类和对象

[[../../../index|首页]] - [[../index|C/C++]] - [[index|Base]]
==类和对象==
----
===构造函数与析构函数===

如果父类存在带参数的`构造函数`，则`C++`子类的`构造函数`必须初始化父类的`构造函数`

初始化语法如下：
{{{
子类构造函数名(参数列表) : 父类构造函数名(参数列表), 其他成员赋值
{
  子类构造函数具体内容
}
}}}

实例化子类对象时，会先调用父类的`构造函数`，然后再调用子类自己的`构造函数`

而销毁对象时顺序恰恰相反，程序会先调用子类自己的`析构函数`，然后再调用父类的`构造函数`

`构造函数`和`析构函数`都不能有返回值，`析构函数`不能带参数
----
===虚函数与多态===

由于在构造子类对象之前会先构造父类对象，所以子类对象的内存等于父类对象的内存再加上自己的部分，这样子类对象与父类对象的起始地址就是一样的

当将一个子类对象的地址赋予一个父类对象的指针时，所有通过该父类对象指针进行的操作都将基于父类执行，因为这个子类对象的地址同时也是其父类对象的地址

如果需要使上述调用基于子类执行，那就需要用到`虚函数`了，它会将绑定延迟到程序运行时，依据对象的具体类型来决定调用哪个函数，这就是`C++`的`多态`

使用`虚函数`只需在需要`多态`特性的父类函数定义之前加上一个`virtual`关键字即可
----
===纯虚函数与抽象===

如果一个类中存在形如`virtual .. f_name( .. ) = 0;`的函数定义，则该函数叫做`纯虚函数`，而该类则称为`抽象类`

继承`抽象类`的子类必须全部实现该父类所定义的`纯虚函数`，如果没有全部实现，则该子类也将是一个`抽象类`
----
<red>date</red> : 2012-10-12
----
